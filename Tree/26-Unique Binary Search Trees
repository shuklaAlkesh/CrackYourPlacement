// struct TreeNode {
//     int val;
//     TreeNode *left;
//     TreeNode *right;
//     TreeNode() : val(0), left(nullptr), right(nullptr) {}
//     TreeNode(int x) : val(x), left(nullptr), right(nullptr) {}
//     TreeNode(int x, TreeNode *left, TreeNode *right) : val(x), left(left), right(right) {}
// };
class Solution {
public:
    // First Approach 
    // vector<TreeNode*> solve(int start, int end) {
    //     vector<TreeNode*> result;
    //     if (start > end) {
    //         result.push_back(nullptr); 
    //         result;
    //     }

    //     for (int i = start; i <= end; ++i) {
    //         vector<TreeNode*> left_Bst = solve(start, i - 1);
    //         vector<TreeNode*> right_Bst = solve(i + 1, end);
    //         for (TreeNode* leftRoot : left_Bst) {
    //             for (TreeNode* rightRoot : right_Bst) {
    //                 TreeNode* root = new TreeNode(i);
    //                 root->left = leftRoot;
    //                 root->right = rightRoot;
    //                 result.push_back(root);
    //             }
    //         }
    //     }
    //     return result;
    // }
    int numTrees(int n) {
        // vector<TreeNode*>result = solve(1,n);
        // return result.size();

        // Second Approach
    
        vector<int> dp(n + 1, 0);
        dp[0] = 1;

        for (int i = 1; i <= n; ++i) {
                for (int j = 0; j < i; ++j) {
                    dp[i] += dp[j] * dp[i - j - 1];
                }
            }
            
        return dp[n];
    }
};