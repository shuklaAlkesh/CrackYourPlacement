// class Solution {
// public:
//     // first method using recursion and having the time complexity is O(2*n * 2^2n)
//     vector<string> result;
//     bool isValid(string curr){
//         int count = 0;
//         for(auto &ch : curr){
//             if(ch == '('){
//                 count++;
//             }else{
//                 count--;
//             }

//             if(count < 0){
//                 return false;
//             }
//         }

//         return count == 0;
//     }
//     void solve(string& curr,int& n ){
//         if(curr.length() == 2*n){
//             if(isValid(curr)){
//                 result.push_back(curr);
//             }
//             return;
//         }

//         curr.push_back('(');
//         solve(curr,n);
//         curr.pop_back();

//         curr.push_back(')');
//         solve(curr,n);
//         curr.pop_back();
//         return ;
//     }
//     vector<string> generateParenthesis(int n) {
//         // Approach 1
//         string curr = "";
//         solve(curr,n);
//         return result;
//     }
// };

// second Approach 

class Solution {
public:
    // first method using recursion and having the time complexity is O(2*n * 2^2n)
    vector<string> result;
    void solve(string& curr,int n, int open,int close){
        if(curr.length() == 2*n){
            result.push_back(curr);
            return;
        }
        if(open < n){
            curr.push_back('(');
            solve(curr,n,open+1,close);
            curr.pop_back();
        }
        if(close < open){
            curr.push_back(')');
            solve(curr,n,open,close+1);
            curr.pop_back();
        }
        return ;
    }
    vector<string> generateParenthesis(int n) {
        // Approach 1
        string curr = "";
        int open = 0;
        int close = 0;
        solve(curr,n,open,close);
        return result;
    }
};